---
id: "01ca0c2e-3be5-40e8-b960-0bda5ca191fc"
title: "Robust telemetry solution for SPA access tracking"
kind: process
created: 2026-01-12
updated: 2026-01-12
review_after: 2026-04-12
status: active
tags: ["jsonl", "logs", "nestjs", "nginx", "planning", "sendbeacon", "spa", "strategic", "telemetry"]
filenames: ["/home/linuxcore/Proyectos/impostor/backend/package.json", "/home/linuxcore/Proyectos/impostor/backend/src/app.module.ts", "/home/linuxcore/Proyectos/impostor/backend/src/main.ts", "/home/linuxcore/Proyectos/impostor/frontend/src/App.tsx", "/home/linuxcore/Proyectos/impostor/frontend/src/main.tsx", "backend/src/telemetry/telemetry.controller", "backend/src/telemetry/telemetry.module", "backend/src/telemetry/telemetry.service", "frontend/src/App.tsx"]
---

# Solution
Si lo que quieres es **desplegar** la app y además **guardar información de accesos** (visitas / uso), tienes 2 planos distintos:

1) **Accesos “HTTP”** (quién entra a `/`, a `/api/word-packs`, etc.).  
2) **Eventos de producto** (ej: “abrió la app”, “empezó partida”, “terminó partida”). Para esto casi siempre necesitas un endpoint de “telemetry” porque la SPA (frontend) puede servirse estática y no siempre golpea al backend en cada pantalla.

Abajo te dejo una solución robusta (recomendada) y varias alternativas por si no encaja.

---

## Solución recomendada (robusta): Nginx/Reverse proxy + Telemetría en backend

### A) Accesos HTTP (sin tocar frontend): logs del servidor web
Si vas a servir el frontend con **Nginx/Caddy/Apache**, ya tienes “access logs” de forma nativa. Esto es lo más estable y barato:

- Te registra: `timestamp`, `path`, `status`, `user-agent`, `referer`, IP (la que vea el proxy), etc.
- Puedes rotarlo con `logrotate`.
- Funciona aunque el JS falle o el usuario bloquee trackers.

**Corner case clave:** si tu backend (Nest) está detrás de Nginx, la IP real llega por `X-Forwarded-For`.

### B) Accesos reales a la app (SPA): endpoint de “visit” + `sendBeacon`
Para registrar “entró a la app” aunque sea SPA, añade un endpoint en Nest y llama desde `App.tsx`.

#### 1) Backend (NestJS): endpoint `/api/telemetry/visit`
Crea un módulo `telemetry` que persista en archivo (JSON Lines) o DB.

**Persistencia simple y muy efectiva: archivo JSONL**
- Ventaja: cero DB, fácil de inspeccionar, ideal para primeras métricas.
- Riesgo: en **multi-instancia** (varios pods/servers) cada instancia guarda su fichero. Si escalas, mejor DB o logs centralizados.

Ejemplo rápido:

`backend/src/telemetry/telemetry.controller.ts`
```ts
import { Body, Controller, Post } from '@nestjs/common';
import { TelemetryService } from './telemetry.service';

@Controller('api/telemetry')
export class TelemetryController {
  constructor(private readonly telemetry: TelemetryService) {}

  @Post('visit')
  async visit(@Body() body: any) {
    // body esperado: { sessionId, path, ts, referrer, ua }
    await this.telemetry.logVisit(body);
    return { ok: true };
  }
}
```

`backend/src/telemetry/telemetry.service.ts`
```ts
import { Injectable } from '@nestjs/common';
import { promises as fs } from 'fs';
import * as path from 'path';

@Injectable()
export class TelemetryService {
  private logFile = path.join(process.cwd(), 'logs', 'telemetry-visits.jsonl');

  async logVisit(payload: any) {
    await fs.mkdir(path.dirname(this.logFile), { recursive: true });

    const entry = {
      ts: new Date().toISOString(),
      type: 'visit',
      ...payload,
    };

    // Importante: append asíncrono; si hay mucho tráfico, mejor cola/buffer.
    await fs.appendFile(this.logFile, JSON.stringify(entry) + '\n', 'utf8');
  }
}
```

`backend/src/telemetry/telemetry.module.ts`
```ts
import { Module } from '@nestjs/common';
import { TelemetryController } from './telemetry.controller';
import { TelemetryService } from './telemetry.service';

@Module({
  controllers: [TelemetryController],
  providers: [TelemetryService],
})
export class TelemetryModule {}
```

Y en `backend/src/app.module.ts`:
```ts
import { Module } from '@nestjs/common';
import { WordPacksModule } from './word-packs/word-packs.module';
import { TelemetryModule } from './telemetry/telemetry.module';

@Module({
  imports: [WordPacksModule, TelemetryModule],
})
export class AppModule {}
```

#### 2) Frontend (Vite/React): registrar visita al montar App
En `frontend/src/App.tsx`, añade un `useEffect` que haga `sendBeacon` (mejor que `fetch` para telemetría):

```ts
import { useEffect, useRef, useState } from 'react';
// ...

function getSessionId() {
  // si localStorage no está disponible, cae a id por carga
  try {
    const key = 'impostor_sid';
    const existing = localStorage.getItem(key);
    if (existing) return existing;
    const sid = crypto.randomUUID();
    localStorage.setItem(key, sid);
    return sid;
  } catch {
    return crypto.randomUUID();
  }
}

function App() {
  const phase = useGameState((state) => state.phase);
  const [isLoading, setIsLoading] = useState(true);

  // IMPORTANTE: En dev con React.StrictMode, el effect puede dispararse 2 veces.
  const sentRef = useRef(false);

  useEffect(() => {
    setIsLoading(false);
  }, []);

  useEffect(() => {
    if (sentRef.current) return;
    sentRef.current = true;

    const API = import.meta.env.VITE_API_URL; // ej: https://tu-dominio.com
    const payload = {
      sessionId: getSessionId(),
      path: window.location.pathname,
      referrer: document.referrer || null,
      ua: navigator.userAgent,
      ts: Date.now(),
    };

    try {
      const ok = navigator.sendBeacon(
        `${API}/api/telemetry/visit`,
        new Blob([JSON.stringify(payload)], { type: 'application/json' })
      );

      // Fallback si sendBeacon falla
      if (!ok) {
        fetch(`${API}/api/telemetry/visit`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
          keepalive: true,
        }).catch(() => {});
      }
    } catch {
      // no rompas la app si telemetry falla
    }
  }, []);

  // ...
}
```

**Corner cases importantes aquí:**
- **React.StrictMode en dev**: duplicará logs si no pones guard (`sentRef`).
- Usuarios con **adblock / privacy**: puede bloquear el endpoint; por eso también es útil el log de Nginx.
- Si despliegas en HTTPS con dominio distinto, ajusta:
  - `VITE_API_URL`
  - CORS en Nest (`FRONTEND_URL`)
- Si quieres IP real en Nest detrás de proxy: en `main.ts` añade `app.set('trust proxy', 1)` (si usas express adapter) y luego usa `X-Forwarded-For` en middleware (si lo implementas).

---

## (Recomendado adicional) Log de requests del backend (API) con Middleware
Esto te da visibilidad de *todas* las llamadas a `/api/*` (word packs, telemetry, etc.) con status y latencia.

- Útil para auditoría, debugging, rate limiting, etc.
- Persistencia: también JSONL o stdout (para Docker + Loki/ELK).

Si quieres, te paso una implementación de `Middleware` que registre `method, url, status, durationMs, ip (anonimizada), user-agent`.

---

## Alternativas si lo anterior no te encaja

### Alternativa 1: Solo logs del servidor (cero cambios de código)
- Frontend servido por Nginx + backend proxied.
- Te quedas con access logs del reverse proxy.
- Contras: no tienes “eventos” (solo requests HTTP).

### Alternativa 2: Guardar en DB (Postgres/SQLite) en vez de ficheros
- Pro: perfecto para queries (“visitas por día”, “usuarios únicos”, etc.) y multi-instancia.
- Contras: más setup (ORM, migraciones).
- Ideal si ya vas a tener DB para otras cosas.

### Alternativa 3: Analítica externa (Plausible/Matomo/Cloudflare Web Analytics)
- Pro: rápido, dashboards listos, sin mantener infraestructura.
- Contras: dependencia externa y temas de privacidad/cookies según herramienta.

---

## Preguntas para cerrarlo bien (y evitar rehacer)
1) ¿Quieres registrar **solo visitas** o también eventos de juego (start game, end game, etc.)?  
2) ¿Vas a desplegar en **1 servidor** (VPS) o piensas escalar a múltiples instancias (Docker/K8s)?  
3) ¿Necesitas guardar IP/UA tal cual, o prefieres **anonimizar** (recomendado por privacidad)?

Con esas respuestas te digo cuál de las 3 opciones conviene y te dejo el código exacto (middleware + esquema de datos) para tu caso.